# BOJ_S1
백준 온라인 저지 silver 1 난이도 문제풀이입니다.

---

## 1890 - 점프

N x N 크기의 배열에 숫자들이 주어진다. 각 칸에서 주어진 숫자만큼 오른쪽 혹은 아래로 점프할 수 있다고 할 때, 왼쪽 위에서 오른쪽 아래로 도달할 수 있는 경로를 구하는 문제

DP를 통해 풀었다.

동일 크기에 dp 배열을 만들어 각 칸 별로 도달할 수 있는 경로의 수를 집어넣었다.

점프의 길이와 해당 칸의 인덱스를 더한 값이 목표하는 위치의 인덱스와 일치하는 칸들의 dp값을 모두 더해 해당칸의 dp값으로 결정하는 방식으로 풀이하였다.

다만, 경로의 범위가 2^63-1 까지 였기때문에 dp배열과 경로수를 세는 변수 모두 long 타입을 사용해야했다.

## 1991 - 트리 순회

22.08.23 풀이

이진 트리의 형태를 생각하고 한 줄에 가장 먼저오는 알파벳의 자손으로 다음에 주어지는 두 알파벳이 된다. "."인 경우, 자손이 없는 것을 뜻할 때, preorder, inorder, postorder 순서로 출력하는 문제

Node클래스를 만들어 String 형태의 알파벳을 저장하도록 하였고, Node를 연결해주는 Tree 클래스도 만들었다.

Tree에 Node들을 연결하는 과정에서 중복을 피하기 위해, 새로운노드를 만들기 이전에 이미 Tree에 해당알파벳의 노드가 있는지 확인하며 노드를 만드는 것이 주요했다. 

## 2564 - 경비원

직사각형 도로 위에 가게의 위치와 경비원의 위치가 주어진다. 직사각형의 크기가 주어지고, 직사각형의 변으로만 움직일 수 있다고 할 때, 경비원으로부터 각 가게까지의 최단거리의 합을 구하시오.

경비원으로부터 가게까지의 최단거리를 구하는 메소드를 선언하여 사용하였다.

경비원이 위, 아래, 좌, 우 모서리 중 어디에 있는지 switch 문으로 확인하고 또 그 안에서 각각, 가게가 상하좌우 어디에 있는지 다시 switch문으로 확인하였다. 그리고 상황에 맞게 최단 거리를 구하는 방식으로 메소드를 선언하였다.

> 보완할 점

이 문제와 같이, 둘 다 움직이는 요소사이의 거리를 구하는 경우, 움직이지 않는 기준점을 정하고, 그 기준점으로 부터의 거리를 각각 구해, 그 차이를 통해 두 요소사이의 거리를 구할 수 있다. 

## 2527 - 직사각형

22.08.21 풀이

두 직사각형의 왼쪽 위 좌표와 오른쪽 아래 좌표가 주어진다고 할 때, 두 직사각형이 겹쳐지는 상태를 출력하는 문제

두 직사각형이 겹쳐지는 상태는 총 네가지가 있다.

직사각형 형태, 선 형태, 점 형태, 겹쳐지지 않음.

가장 바깥 범위부터 차례대로 가질 수 있는 상태의 조건을 달아 모든 조건에 대해 판별하도록 구현을 하였다.

> 다른 방법

각 x좌표와 y좌표에 대해 겹쳐지는 좌표의 수를 구한다. 그 겹쳐지는 좌표의 수에 따라 겹쳐지는 형태를 판별하여 출력한다.

모든 조건에 대해 탐색하지 않아도 되는 더 좋은 풀이 방법

## 16926 - 배열 돌리기 1

배열을 가장 바깥쪽부터 안쪽까지 겹겹이 반시계방향으로 한칸씩 움직이게 하는 문제

델타이동을 이용하여 풀이하였다.

가장 왼쪽위부터 오른쪽으로 움직이기 시작하여, 경계선 바깥을 만나거나 앞칸에 값이 있는 경우, 우하좌상 순서로 방향을 바꾸어 이동하도록 하였다.

이때, 배열을 돌리는 규칙을 이용하여, 원래의 배열에서 값을 가져와 임시 배열에 값을 넣었다.

오른쪽으로 이동하고 있을 때, 열 + 1

아래로 이동하고 있을 때, 행 + 1

왼쪽으로 이동하고 있을 때, 열 - 1

위로 이동하고 있을 때, 행 - 1 칸의 값을 가져와 저장하였다.

단, 겹마다 가장 마지막인, 위로 이동하는 중에 앞에 값이 있는 경우엔, 방향을 바꾸고 값을 바꾸는 것이 아니라, 값을 바꾸고 방향을 바꾼 뒤에 다음 겹으로 넘어가야 했다.

> 개선 방안

위에서 가장 마지막에 언급한, 겹의 마지막 칸을 처리하는 것이 불편하기 때문에, 겹별로 회전을 따로 진행한다면 더 간단하고 쉬운 코드가 될 것이다.

## 16935 - 배열 돌리기 3

1부터 6까지 주어진 규칙에 따라 배열을 돌리는 문제

각 규칙에 맞게 배열을 돌리기만 하면 된다. 

상하 혹은 좌우의 경우, 같은 행 혹은 열만 바꿔주면 된다.

시계방향, 반시계방향의 경우, 행과 열이 서로 반대로 영향을 주기 때문에, 행과 열을 바꾸어 규칙을 찾는 것이 주요했다.

이과정에서, N과 M이 바뀌기 때문에 해당 수를 바꿔주는 것이 중요했다.

4등분으로 나누어, 옮기는 것은 각 4등분의 왼쪽위 좌표를 기준으로 원배열에서 복사해오는 방식으로 풀이였다.