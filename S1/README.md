# BOJ_S1
백준 온라인 저지 silver 1 난이도 문제풀이입니다.

---

## 1074 - Z

22.09.25 풀이

2^N x 2^N 크기의 배열을 왼쪽 위부터 Z모양으로 차례대로 번호를 메긴다고 할 때, r행 c열 위치는 몇 번을 받게 되는 지 출력하는 문제

재귀함수를 통해 풀이하였다.

일단 해당 위치가 현재 배열에서 몇 사분면에 위치하는 지 판단하여, 해당 사분면보다 앞쪽에 있는 숫자들을 더하고, 해당 사분면을 하나의 배열로 생각하여, 행과 열을 빼주어 다음 재귀함수를 호출하는 방식으로 풀이하였다.

## 1149 - RGB 거리

22.10.04 풀이

N개의 집을 각각 RGB색으로 칠하는 비용이 주어진다. 인접한 집은 같은 색으로 칠할 수 없을 때, 최소한의 비용으로 집을 모두 칠할 때 드는 비용을 구하는 문제

인접한 집은 같은 색으로 칠할 수 없다는 조건 때문에, 특정 위치의 집은 바로 앞 집의 색을 제외한 색 중에 선택해야한다.

이와 같은 규칙을 바탕으로 DP배열을 만들어 채워나가는 것으로 풀이하였다.

N개의 집이 가질 수 있는 상태는 RGB 세가지 이기 때문에 N x 3 크기의 DP 배열을 만들어, 맨 앞집을 초기값으로 지정하고

그 다음 집부터는, R을 칠할 때는 이전 집의 GB 비용중 적은 것에 더하는 방식으로 DP 배열을 모두 채워, 가장 적은 비용이 드는 것을 선택하여 출력하였다.

> 시행착오

처음에는 완전 탐색을 통해서 모든 경우에 대해 가장 적은 비용이 드는 경우의 수를 찾으려고 하였으나, 시간 초과가 발생하였다.

탐색과정에서 중간 경우의 수를 모두 기록해야하는 것이 아니라면, DFS보단 DP가 더 유리해 보인다.

## 1697 - 숨바꼭질

22.09.29 풀이

숫자 N, K를 입력받아서 N에 연산을 +1, -1, *2 만을 이용하여 K를 만드는 최소 횟수를 구하는 문제

값과 연산 횟수를 저장하는 Node 클래스를 만들어 bfs를 이용하여 연산 횟수를 계산하였다.

방문 처리를 하지 않고 bfs를 진행하면 반복적인 방문에 시간 초과가 나온다.

boolean 배열을 통해 방문처리를 하였다.

## 1743 - 음식물 피하기

22.09.28 풀이

복도의 좌표 크기가 주어지고, 쓰레기가 떨어져 있는 위치가 좌표가 주어질 때, 가장 큰 쓰레기의 크기를 구하는 문제

dfs를 통해 풀이하였다.

복도의 크기와 같은 boolean배열을 만들어 방문 처리를 하였다.

쓰레기의 좌표를 List에 넣고 List에 하나씩 빼고 해당 좌표가 방문이 되어있지 않다면 dfs를 진행하는 방식으로 풀이하였다.

dfs 과정에서 자신의 좌표에서 상하좌우의 좌표가 list에 있는 지 확인하는 과정을 거쳐서 진행하였다.

## 1890 - 점프

N x N 크기의 배열에 숫자들이 주어진다. 각 칸에서 주어진 숫자만큼 오른쪽 혹은 아래로 점프할 수 있다고 할 때, 왼쪽 위에서 오른쪽 아래로 도달할 수 있는 경로를 구하는 문제

DP를 통해 풀었다.

동일 크기에 dp 배열을 만들어 각 칸 별로 도달할 수 있는 경로의 수를 집어넣었다.

점프의 길이와 해당 칸의 인덱스를 더한 값이 목표하는 위치의 인덱스와 일치하는 칸들의 dp값을 모두 더해 해당칸의 dp값으로 결정하는 방식으로 풀이하였다.

다만, 경로의 범위가 2^63-1 까지 였기때문에 dp배열과 경로수를 세는 변수 모두 long 타입을 사용해야했다.

## 1991 - 트리 순회

22.08.23 풀이 

이진 트리의 형태를 생각하고 한 줄에 가장 먼저오는 알파벳의 자손으로 다음에 주어지는 두 알파벳이 된다. "."인 경우, 자손이 없는 것을 뜻할 때, preorder, inorder, postorder 순서로 출력하는 문제

Node클래스를 만들어 String 형태의 알파벳을 저장하도록 하였고, Node를 연결해주는 Tree 클래스도 만들었다.

Tree에 Node들을 연결하는 과정에서 중복을 피하기 위해, 새로운노드를 만들기 이전에 이미 Tree에 해당알파벳의 노드가 있는지 확인하며 노드를 만드는 것이 주요했다. 

## 2468 - 안전 영역

22.10.02 풀이

N x N 크기의 배열에 각 땅의 높이가 주어진다. 0일부터 100일까지 해당 일수와 같은 높이가 물에 잠긴다고 할 때, 물에 잠기지 않은 땅의 갯수를 구하는 문제

1부터 100까지 일수를 늘려가면서, 땅의 갯수를 세는 것으로 풀이하였다.

매일 방문처리에 필요한 boolean배열을 초기화 해주었다. 

매일 각 칸에 대해서 방문하지 않은 칸에 대해, 현재 일수보다 높이가 높다면, bfs를 통해서 해당 칸과 연결된 땅은 모두 방문처리를 해주고, 땅의 갯수를 1 늘려가는 방식으로 땅의 갯수를 세었다.

일 수를 하나씩 늘려가면서, 만약 땅의 갯수가 0이 나온다면, 그 이후로는 더이상 땅이 나올 수가 없으므로, 중지하였다.

## 2564 - 경비원

직사각형 도로 위에 가게의 위치와 경비원의 위치가 주어진다. 직사각형의 크기가 주어지고, 직사각형의 변으로만 움직일 수 있다고 할 때, 경비원으로부터 각 가게까지의 최단거리의 합을 구하시오.

경비원으로부터 가게까지의 최단거리를 구하는 메소드를 선언하여 사용하였다.

경비원이 위, 아래, 좌, 우 모서리 중 어디에 있는지 switch 문으로 확인하고 또 그 안에서 각각, 가게가 상하좌우 어디에 있는지 다시 switch문으로 확인하였다. 그리고 상황에 맞게 최단 거리를 구하는 방식으로 메소드를 선언하였다.

> 보완할 점

이 문제와 같이, 둘 다 움직이는 요소사이의 거리를 구하는 경우, 움직이지 않는 기준점을 정하고, 그 기준점으로 부터의 거리를 각각 구해, 그 차이를 통해 두 요소사이의 거리를 구할 수 있다. 

## 2527 - 직사각형

22.08.21 풀이

두 직사각형의 왼쪽 위 좌표와 오른쪽 아래 좌표가 주어진다고 할 때, 두 직사각형이 겹쳐지는 상태를 출력하는 문제

두 직사각형이 겹쳐지는 상태는 총 네가지가 있다.

직사각형 형태, 선 형태, 점 형태, 겹쳐지지 않음.

가장 바깥 범위부터 차례대로 가질 수 있는 상태의 조건을 달아 모든 조건에 대해 판별하도록 구현을 하였다.

> 다른 방법

각 x좌표와 y좌표에 대해 겹쳐지는 좌표의 수를 구한다. 그 겹쳐지는 좌표의 수에 따라 겹쳐지는 형태를 판별하여 출력한다.

모든 조건에 대해 탐색하지 않아도 되는 더 좋은 풀이 방법

## 16926 - 배열 돌리기 1

배열을 가장 바깥쪽부터 안쪽까지 겹겹이 반시계방향으로 한칸씩 움직이게 하는 문제

델타이동을 이용하여 풀이하였다.

가장 왼쪽위부터 오른쪽으로 움직이기 시작하여, 경계선 바깥을 만나거나 앞칸에 값이 있는 경우, 우하좌상 순서로 방향을 바꾸어 이동하도록 하였다.

이때, 배열을 돌리는 규칙을 이용하여, 원래의 배열에서 값을 가져와 임시 배열에 값을 넣었다.

오른쪽으로 이동하고 있을 때, 열 + 1

아래로 이동하고 있을 때, 행 + 1

왼쪽으로 이동하고 있을 때, 열 - 1

위로 이동하고 있을 때, 행 - 1 칸의 값을 가져와 저장하였다.

단, 겹마다 가장 마지막인, 위로 이동하는 중에 앞에 값이 있는 경우엔, 방향을 바꾸고 값을 바꾸는 것이 아니라, 값을 바꾸고 방향을 바꾼 뒤에 다음 겹으로 넘어가야 했다.

> 개선 방안

위에서 가장 마지막에 언급한, 겹의 마지막 칸을 처리하는 것이 불편하기 때문에, 겹별로 회전을 따로 진행한다면 더 간단하고 쉬운 코드가 될 것이다.

## 16935 - 배열 돌리기 3

1부터 6까지 주어진 규칙에 따라 배열을 돌리는 문제

각 규칙에 맞게 배열을 돌리기만 하면 된다. 

상하 혹은 좌우의 경우, 같은 행 혹은 열만 바꿔주면 된다.

시계방향, 반시계방향의 경우, 행과 열이 서로 반대로 영향을 주기 때문에, 행과 열을 바꾸어 규칙을 찾는 것이 주요했다.

이과정에서, N과 M이 바뀌기 때문에 해당 수를 바꿔주는 것이 중요했다.

4등분으로 나누어, 옮기는 것은 각 4등분의 왼쪽위 좌표를 기준으로 원배열에서 복사해오는 방식으로 풀이였다.

이 과정에서 각 행과 열이 0일 때와 0이 아닐 때로 나누어, 왼쪽 위 좌표를 지정해 주었다.