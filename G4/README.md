# BOJ_G4
백준 온라인 저지 gold 4 난이도 문제풀이입니다.

---

## 1922 - 네트워크 연결

22.09.30 풀이

N개의 컴퓨터를 연결하는 M개의 간선이 주어진다. 모든 컴퓨터를 최소 비용으로 연결할 때, 그 최소 비용을 출력하는 문제

간선의 정보를 입력받아 List에 저장하고 가중치로 정렬하여 하나씩 뽑아 크루스칼 알고리즘을 적용하였다.

> 기억해둘 것

union 을 진행할 떄, 각 정점의 대표자를 연결해야한다. 

## 2116 - 주사위 쌓기

주사위 설계도 상의 위치에 따라 순서대로 1~6까지의 값이 임의의 순서로 주어진다. N개의 주사위 설계도가 주어지고, 주사위들을 순서대로 쌓아 올린다고 할 때, 주사위끼리 맞닿는 면은 같은 수를 가져야한다. 이와 같은 규칙으로 주사위를 쌓았을 때, 옆면 한줄 합산의 최대값을 구하는 문제

설계도 상으로 인덱스 기준 (0, 5), (1, 3), (2, 4) 끼리 반대편이다. 따라서 각 주사위 별로 위아래 면을 제외한 면 중 최대값을 더하는 방식으로 진행하였다.

1번 주사위의 아래면이 될 숫자를 선정한다. 6개 모두 파악할 예정이다.

한면을 선택하면 위 규칙에 따라 모든 주사위의 윗면과 아랫면이 결정된다. 

각 주사위의 옆면 중 최댓값을 더해나가서 그 합산된 값들 중에서 1번 주사위의 면에 따라서 최댓값을 구해 출력하는 방식으로 풀이하였다.

## 2239 - 스도쿠

22.09.22 풀이

아래 2580과 같은 방식으로 풀이하였다.

## 2580 - 스도쿠

22.09.21 풀이

빈칸이 있는 스도쿠를 입력받아, 스도쿠 규칙에 따라 채워 출력하는 문제

스도쿠를 한칸씩 입력받으면서 빈칸의 경우, List에 add하며 저장하였다.

그 이후, list에서 빈칸을 하나씩 꺼내 1부터 9까지 넣고 숫자를 넣을 때마다 해당 숫자가 들어갔을 때, 스도쿠가 유효한지 판단해주어야 했다.

1부터 9까지 모든 숫자가 유효하지 않을 경우, 다시 해당칸을 0으로 만들어 주는 것이 중요하다.

## 7662 - 이중 우선순위 큐

22.09.28 풀이

명령어 I, D에 따라서 수를 큐에 넣고, 최댓값 혹은 최소값을 반환해주는 자료구조를 구현하는 문제

일반적인 배열을 이용하여 구현할 경우 시간 초과가 문제가 된다.

따라서 탐색이 빠른 자료구조를 이용해야 했고, TreeMap을 이용하였다.

삽입을 할 때, 현재 map에 해당 수가 있다면 value + 1을 없다면 1을 넣기 위해, getOrDefault() 메소드를 이용하였다.

제거를 할 때는, pollLastEntry() 와 pollFirstEntry() 메소드를 이용하여 value가 1이면 제거, 아니라면 1을 뺴고 다시 넣어주는 방식으로 진행하였다.

> 더 나은 방법

pollLastEntry보단 getLastKey() 혹은 getFirstKey() 메소드를 이용하여 value를 받아 1을 빼주는 방식이 더 효율적이 었을 것 같다.

## 9663 - N-Queen

22.09.21 풀이

N x N 체스판에 N개의 Queen을 서로 공격할 수 없도록 위치시키는 경우의 수를 구하는 문제

한 행에 Queen을 위치시키는 메소드를 정의하여 재귀함수를 통해 N개의 행에 Queen을 배치하도록 풀이하였다.

이 과정에서 Queen을 위치시킬 때, 지금까지 배치한 Queen과 공격할 수 있는 위치에 있는 지 판단하는 메소드도 정의하여 사용하였다.

공격할 수 없는 경우에만 배치하는 방식으로 진행하였다.

## 9935 - 문자열 폭발

22.09.04 풀이

문자열에서 특정 문자열을 지우고, 그 문자열을 지우고 난 뒤에 특정 문자열이 있다면 또 지우는 과정을 계속 반복하여 최종적으로 남는 문자열을 출력하는 문제

일단 기본 문자열과 폭발 문자열을 입력 받는다.

그리고 문자열을 하나씩 담을 스택과 폭발 문자열을 테스트할 스택을 각각 만든다.

기본 문자열에서 앞에서 부터 하나씩 스택에 넣는다.

하나씩 넣으면서 해당 문자가 폭발 문자열의 마지막 문자와 같은 경우, 해당 스택에서 폭발 문자열의 길이만큼 하나씩 꺼내면서 test 스택에 넣는다.

폭발 문자열의 뒤에서 부터 비교해가면서 하나라도 틀렸다면 지금까지 꺼냈던 문자들을 다시 넣고, 끝까지 맞았다면 test 스택을 비워버린다.

위 과정을 기본문자열의 끝까지 진행하여, 스택에 남은 것을 출력하는 것으로 풀이하였다.

## 14500 - 테트로미노

22.09.22 풀이

각 칸에 숫자가 쓰여진 판이 주어지고, 그 판 위에 테트로미노 한 개를 올려 놓는다고 할 때, 그 밑에 쓰여진 수들의 합의 최대롤 구하는 문제

모든 칸에 대해서, 모든 테트로미노를 올려놓는 경우를 완전 탐색으로 풀이하였다.

T모양을 제외한 테트로미노의 경우, 재귀를 통해 한 칸씩 이동하며 합산을 더하는 방식으로 구하였고,

T모양의 경우, 꼭짓점을 제외하고, 모든 지점이 T모양의 중심이 되는 모든 경우에 대해 합산을 구하여 비교하였다.

## 17069 - 파이프 옮기기 2

22.09.20 풀이

파이프를 왼쪽 위에서 오른쪽 아래까지 옮기는 경우의 수를 구하는 문제

DP를 이용하여 풀이하였다.

각 지점 별로 파이프의 오른쪽 부분이 위치할 수 있는 경우는 세가지, 가로, 세로, 대각선 형태이다.

가로로 존재하게 되는 경우는, 왼쪽칸에서 대각선 형태 + 가로 형태

세로로 존재하게 되는 경우는, 위쪽칸에서 대각선 형태 + 세로 형태

대각선으로 존재하게 되는 경우는, 왼쪽 위칸에서 대각선 + 가로 + 세로

위 세가지 관계를 바탕으로 DP칸을 채워나가게 되었다.

추가적으로 고려해야하는 상황은 벽으로 표시된 곳. 벽으로 표시된 곳은 파이프가 존재할 수 없으므로 {0, 0, 0}으로 만들어 주었고

왼쪽이나 위쪽에 벽이 존재하는 경우에는 대각선으로 존재할 수 없으므로 대각선의 경우의 수를 0으로 만들어 주었다.

파이프 옮기기 1과 다른 점은 경우의 수가 21억을 넘어갈 수 있기에 long자료형을 담는 배열이어야 한다는 것이다.