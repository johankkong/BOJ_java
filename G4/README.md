# BOJ_G4
백준 온라인 저지 gold 4 난이도 문제풀이입니다.

---

## 1922 - 네트워크 연결

22.09.30 풀이

N개의 컴퓨터를 연결하는 M개의 간선이 주어진다. 모든 컴퓨터를 최소 비용으로 연결할 때, 그 최소 비용을 출력하는 문제

간선의 정보를 입력받아 List에 저장하고 가중치로 정렬하여 하나씩 뽑아 크루스칼 알고리즘을 적용하였다.

> 기억해둘 것

union 을 진행할 떄, 각 정점의 대표자를 연결해야한다. 

## 2116 - 주사위 쌓기

주사위 설계도 상의 위치에 따라 순서대로 1~6까지의 값이 임의의 순서로 주어진다. N개의 주사위 설계도가 주어지고, 주사위들을 순서대로 쌓아 올린다고 할 때, 주사위끼리 맞닿는 면은 같은 수를 가져야한다. 이와 같은 규칙으로 주사위를 쌓았을 때, 옆면 한줄 합산의 최대값을 구하는 문제

설계도 상으로 인덱스 기준 (0, 5), (1, 3), (2, 4) 끼리 반대편이다. 따라서 각 주사위 별로 위아래 면을 제외한 면 중 최대값을 더하는 방식으로 진행하였다.

1번 주사위의 아래면이 될 숫자를 선정한다. 6개 모두 파악할 예정이다.

한면을 선택하면 위 규칙에 따라 모든 주사위의 윗면과 아랫면이 결정된다. 

각 주사위의 옆면 중 최댓값을 더해나가서 그 합산된 값들 중에서 1번 주사위의 면에 따라서 최댓값을 구해 출력하는 방식으로 풀이하였다.

## 2239 - 스도쿠

22.09.22 풀이

아래 2580과 같은 방식으로 풀이하였다.

## 2580 - 스도쿠

22.09.21 풀이

빈칸이 있는 스도쿠를 입력받아, 스도쿠 규칙에 따라 채워 출력하는 문제

스도쿠를 한칸씩 입력받으면서 빈칸의 경우, List에 add하며 저장하였다.

그 이후, list에서 빈칸을 하나씩 꺼내 1부터 9까지 넣고 숫자를 넣을 때마다 해당 숫자가 들어갔을 때, 스도쿠가 유효한지 판단해주어야 했다.

1부터 9까지 모든 숫자가 유효하지 않을 경우, 다시 해당칸을 0으로 만들어 주는 것이 중요하다.

## 3190 - 뱀

22.10.23 풀이

뱀 게임의 규칙에 따라, 몇 초간 게임이 유지되는 지 계산하는 문제

뱀의 방향을 바꾸는 시간과 방향을 배열의 형태로 Queue에 저장하여 제일 위에 있는 것부터 비교하며 진행하였다.

머리를 앞으로 하나씩 늘리면서 벽이나 자신의 몸에 부딪히는 지 확인하였다.

사과를 먹지 못한 경우, 꼬리가 머리쪽으로 한칸 따라와야하는데, 뱀이 지나가는 좌표를 Queue에 넣어 순서대로 따라갈 수 있도록 하였다.

> 어려웠던 점

처음에 꼬리가 따라가는 것을, Queue를 이용하지 않고, 꼬리에서 주변을 탐색하는 방향으로 진행하였는데, 이처럼 진행할 경우, 몸이 붙어있는 경우, 꼬리가 이상한 방향으로 붙어버리는 문제점이 있었다.

## 7662 - 이중 우선순위 큐

22.09.28 풀이

명령어 I, D에 따라서 수를 큐에 넣고, 최댓값 혹은 최소값을 반환해주는 자료구조를 구현하는 문제

일반적인 배열을 이용하여 구현할 경우 시간 초과가 문제가 된다.

따라서 탐색이 빠른 자료구조를 이용해야 했고, TreeMap을 이용하였다.

삽입을 할 때, 현재 map에 해당 수가 있다면 value + 1을 없다면 1을 넣기 위해, getOrDefault() 메소드를 이용하였다.

제거를 할 때는, pollLastEntry() 와 pollFirstEntry() 메소드를 이용하여 value가 1이면 제거, 아니라면 1을 뺴고 다시 넣어주는 방식으로 진행하였다.

> 더 나은 방법

pollLastEntry보단 getLastKey() 혹은 getFirstKey() 메소드를 이용하여 value를 받아 1을 빼주는 방식이 더 효율적이 었을 것 같다.

## 9663 - N-Queen

22.09.21 풀이

N x N 체스판에 N개의 Queen을 서로 공격할 수 없도록 위치시키는 경우의 수를 구하는 문제

한 행에 Queen을 위치시키는 메소드를 정의하여 재귀함수를 통해 N개의 행에 Queen을 배치하도록 풀이하였다.

이 과정에서 Queen을 위치시킬 때, 지금까지 배치한 Queen과 공격할 수 있는 위치에 있는 지 판단하는 메소드도 정의하여 사용하였다.

공격할 수 없는 경우에만 배치하는 방식으로 진행하였다.

## 9935 - 문자열 폭발

22.09.04 풀이

문자열에서 특정 문자열을 지우고, 그 문자열을 지우고 난 뒤에 특정 문자열이 있다면 또 지우는 과정을 계속 반복하여 최종적으로 남는 문자열을 출력하는 문제

일단 기본 문자열과 폭발 문자열을 입력 받는다.

그리고 문자열을 하나씩 담을 스택과 폭발 문자열을 테스트할 스택을 각각 만든다.

기본 문자열에서 앞에서 부터 하나씩 스택에 넣는다.

하나씩 넣으면서 해당 문자가 폭발 문자열의 마지막 문자와 같은 경우, 해당 스택에서 폭발 문자열의 길이만큼 하나씩 꺼내면서 test 스택에 넣는다.

폭발 문자열의 뒤에서 부터 비교해가면서 하나라도 틀렸다면 지금까지 꺼냈던 문자들을 다시 넣고, 끝까지 맞았다면 test 스택을 비워버린다.

위 과정을 기본문자열의 끝까지 진행하여, 스택에 남은 것을 출력하는 것으로 풀이하였다.

## 10282 - 해킹

22.10.03 풀이

컴퓨터의 갯수와 바이러스가 퍼질 수 있는 방향과 그 시간이 주어질 때, 바이러스가 감염된 컴퓨터가 주어지고 가능한 모든 컴퓨터가 감염되었다고 할 때, 감염된 컴퓨터의 수와 걸린 시간을 구하는 문제

다익스트라 알고리즘을 사용하였다.

주어진 바이러스의 시작 지점으로부터 얼마나 걸려 다른 컴퓨터가 감염되는 지 알 수 있는 알고리즘이다.

처음에는 인접 배열의 형태로 입력받고 PriorityQueue도 사용하지 않았지만, 그러한 풀이로 제출했을 시 메모리 초과가 발생하였다.

그 이후에는, 다익스트라 배열에서 최솟값을 찾는 과정을 줄이기 위해 PriorityQueue를 사용했지만, 이번에도 시간 초과가 발생하였다.

그 다음에는 인접 배열의 형태로 입력을 받는 것이 공간 복잡도를 높이는 것 같아, 인접 리스트의 형태로 입력을 받아서 실행하는 것을 통해 풀이할 수 있었다.

## 14500 - 테트로미노

22.09.22 풀이

각 칸에 숫자가 쓰여진 판이 주어지고, 그 판 위에 테트로미노 한 개를 올려 놓는다고 할 때, 그 밑에 쓰여진 수들의 합의 최대롤 구하는 문제

모든 칸에 대해서, 모든 테트로미노를 올려놓는 경우를 완전 탐색으로 풀이하였다.

T모양을 제외한 테트로미노의 경우, 재귀를 통해 한 칸씩 이동하며 합산을 더하는 방식으로 구하였고,

T모양의 경우, 꼭짓점을 제외하고, 모든 지점이 T모양의 중심이 되는 모든 경우에 대해 합산을 구하여 비교하였다.

## 14502 - 연구소

22.10.27 풀이

연구소 구조를 보여주는 배열이 주어지고, 빈칸에 벽을 3개 세울 수 있다고 할 때, 바이러스가 최소로 퍼졌을 때의 안전 구역의 수를 구하는 문제

모든 빈칸에 대해서, 임의로 3칸을 정해서 벽을 세운 뒤, 모든 바이러스로 부터 bfs를 진행하여, 빈칸의 수를 구하는 방식으로 풀이하였다.

각 칸의 정보는 정수 배열의 형태로 저장하였다.

빈칸을 저장하는 List와 바이러스의 위치를 저장하는 List를 만들어 사용하였다.

임의의 세칸을 고르는 방식은 3중 for문을 이용하였다.

각 빈칸을 벽으로 만들고 다시 빈칸으로 만들어주면서 bfs를 반복하였다.

## 16202 - MST 게임

22.10.24 풀이

그래프의 간선들이 주어지고, 간선을 하나씩 제외해가면서 MST를 만들어보는 문제

Edge클래스를 만들어, 간선들을 구현하였고, 해당 간선들을 List에 넣어 저장하였다.

크루스칼 알고리즘을 이용하여 MST를 만들었고, MST를 만들 수 없는 경우엔, 즉시 게임을 중지하고, 나머지 결과를 0으로 만들었다.

간선을 하나씩 제외하는 것은 List에서 맨 앞 간선을 지우는 방식으로 제거하였다.

## 17069 - 파이프 옮기기 2

22.09.20 풀이

파이프를 왼쪽 위에서 오른쪽 아래까지 옮기는 경우의 수를 구하는 문제

DP를 이용하여 풀이하였다.

각 지점 별로 파이프의 오른쪽 부분이 위치할 수 있는 경우는 세가지, 가로, 세로, 대각선 형태이다.

가로로 존재하게 되는 경우는, 왼쪽칸에서 대각선 형태 + 가로 형태

세로로 존재하게 되는 경우는, 위쪽칸에서 대각선 형태 + 세로 형태

대각선으로 존재하게 되는 경우는, 왼쪽 위칸에서 대각선 + 가로 + 세로

위 세가지 관계를 바탕으로 DP칸을 채워나가게 되었다.

추가적으로 고려해야하는 상황은 벽으로 표시된 곳. 벽으로 표시된 곳은 파이프가 존재할 수 없으므로 {0, 0, 0}으로 만들어 주었고

왼쪽이나 위쪽에 벽이 존재하는 경우에는 대각선으로 존재할 수 없으므로 대각선의 경우의 수를 0으로 만들어 주었다.

파이프 옮기기 1과 다른 점은 경우의 수가 21억을 넘어갈 수 있기에 long자료형을 담는 배열이어야 한다는 것이다.

## 17144 - 미세먼지 안녕!

22.10.18 풀이

T초 동안 미세먼지의 확산과 공기청정기에 의한 공기 이동이 1초에 한번씩 일어난다고 할 때, T초 후에 미세먼지의 합을 구하는 문제

각 칸의 원래 미세먼지 수와 확산에 의해 해당칸에 더해질 수를 따로 가지는 Cell 클래스를 만들어 사용하였다.

이렇게 하려고한 이유는, 원래 배열에 확산에 의한 값을 더해버리면, 그 다음 칸이 확산될 때 영향을 미치기 때문이다.

위와 칸은 클래스를 만들어 T초동안 확산과 공기청정기에 의한 이동을 구현하였다.

각 과정은 델타이동을 이용하여 구현하였다.

## 17281 - ⚾

야구의 규칙에 따라, N이닝을 진행하는 데, 9명의 선수들의 이닝 별 어떤 안타를 치는 지 정보가 주어진다. 최대 점수를 낼 수 있는 타선을 구성한다고 할 때, 최대 점수를 구하는 문제.

9명의 선수에 대해 모든 타순을 테스트 해보는 것으로 문제를 풀이하였다.

순열을 통해서 타순을 결정한 뒤에, 주어진 이닝 동안 게임을 진행하여 얻는 점수를 계산하였다.

## 17406 - 배열 돌리기 4

22.10.17 풀이

배열 돌리기의 규칙이 주어지고, 명령이 K개 주어진다. K개의 명령을 순서는 마음대로 바꿀수 있을 때, 한 행의 합 중 최소값이 최소가 되는 명령의 순서에서 해당 최소값을 구하는 문제

먼저, 원본 배열과 명령들을 배열에 저장한다.

명령들의 순서를 순열을 통해, 모든 순서들을 만들어 낸다.

모든 순서들에서, 각 명령을 수행하여 결과를 비교한다.

이 때, 각 순서에서 원본 배열을 해치면 안되기 때문에, 한번 만든 순서를 시험할 때는 배열을 복사사여 사용하여야한다. 

## 17471 - 게리맨더링

22.10.16 풀이

주어진 그래프를 두 그룹으로 나누는데, 각 그룹은 반드시 이어져 있어야한다. 두 그룹의 인원수 합의 차이가 최소가 될 때의 인원수 차이를 구하는 문제

가장 먼저, 주어진 정점들을 두 그룹으로 나누는 모든 경우의 수를 조합을 통해 구성한다.

그 후, 각 그룹에서 하나씩만 선정하여 dfs를 통해 같은 그룹인 정점만 방문처리를 진행한다.

방문처리를 완료한 뒤, 모든 정점을 방문했다면, 그룹별로 연결이 가능한 것이므로, 인원수 차이를 계산한다.

방문처리가 되지 않은 정점이 존재하는 경우, 해당 두 그룹은 연결될 수 없는 그룹이므로 인원수 차이를 계산하지 않는다.