# BOJ_G5
백준 온라인 저지 gold 5 난이도 문제풀이입니다.

---

## 2293 - 동전 1

22.08.23 풀이

n가지의 동전의 단위가 각각 주어지고, 금액 k원이 주어진다. n가지의 동전을 가지고 k원을 표현하는 경우의 수를 구하는 문제

DP를 활용한 문제. k원이 목표이기 때문에 0원부터 시작하는 k+1 길이의 dp배열을 생성한다.

조합은 같고 순서는 다른 경우, 같은 경우의 수로 취급하기 때문에 각각의 단위 화폐부터 고려해야 중복을 피할 수 있다.

각 화폐의 단위별로 dp배열을 채우는 방식으로 진행하면 된다.

> 생각해야 하는 점

dp배열을 무조건적으로 채우려고 바깥쪽 for문을 dp를 사용하기 보다 여러 조건에 대해 dp배열을 여러번 채우는 방식도 생각해 볼 수 있다.

## 2294 - 동전 2

22.08.23 풀이

위 동전 1과 비슷한 문제지만, 이번에는 목표한 가격을 채우기 위한 최소한의 동전 갯수는 출력하는 문제

최소 갯수만 구하면 되는 것이기 때문에, 순서가 다르게 중복되는 경우는 상관이 없다.

따라서, 각 dp 값을 순차적으로 구해주면서, 해당 칸에서 각 화폐의 단위별로 이전 칸의 dp값 중 최소값에 1을 더해주는 것으로 dp배열을 채워나갔다.

## 7576 - 토마토

22.09.27 풀이

N x M 크기의 토마토 농장에 익은 토마토의 위치와 벽의 위치가 주어질 때, 하루에 한 칸씩 옆에 있는 토마토를 익게 한다. 토마토 농장이 익은 토마토로 가득차는 데까지 걸리는 시간을 구하는 문제

bfs 기본이 되는 문제이다.

맨 처음 입력을 받으면서 1의 좌표를 bfs에 이용할 queue에 미리 다 넣어두었고, 벽의 경우엔 이미 방문한 것으로 처리하였다.

좌표를 저장하면서 익는데 걸린 날을 같이 저장하는 것을 통해서 queue에서 꺼낼 때, 현재 날짜 보다 더 늦은 날짜가 있다면 해당 날짜를 저장하는 방식으로 풀이하였다.

bfs를 마친 뒤, 아직 방문처리가 되지 않은 칸이 있다면 불가능한 것으로 판단하고 -1을 출력하였다.

## 12865 - 평범한 배낭

22.08.25 풀이

배낭에 주어진 무게를 넘지 않도록 물건을 담으려고 할 때, 각 물건의 무게와 만족도가 주어진다. 배낭에 물건들을 담아 얻을 수 있는 최대 만족도를 구하는 문제

DP를 이용하여 풀이하였다.

비슷한 문제들이 있었지만, 이번 문제에서의 핵심은 물건의 반복 사용이 불가하다는 것이었다.

기존처럼 DP배열을 0부터 차례대로 채울 경우, 한 물건이 여러번 들어가게 되어 정확한 답을 얻을 수 없었다.

이를 해결하기 위해서, DP 배열을 뒤부터 채우는 방식을 채택하였다. 

앞쪽부터 채우게 되면 이번 물건이 시행한 칸에 대해 다시 한 번 더해주게 되는 반면, 뒤쪽부터 채우게 되면, 이번 물건에서 시행한 칸이 다음 시행에 영향을 주지 않아, 한 물건을 여러번 사용하게 되는 오류를 피할 수 있다.

## 14503 - 로봇 청소기

22.09.20 풀이

1이 벽 0이 바닥으로 이루어진 공간이 주어지고, 로봇 청소기가 움직이는 규칙에 따라 청소를 한다고 할 때, 로봇 청소기가 몇 칸을 청소하였는 지 출력하는 문제.

문제에 주어진 규칙대로 코드를 작성하여 풀이하였다.

그 과정에서 청소를 한 곳은 벽과 구분하기 위하여 2로 표시하였다. 

델타 이동을 이용하여 풀이하였다.

## 15686 - 치킨 배달

22.08.29 풀이

N x N 좌표에 1은 집, 2는 치킨집으로 표시된다. 치킨집 중에서 M개만 뽑아 남기고 나머지는 없앤다고 했을 때, 각 집에서 가장 가까운 치킨집까지의 거리 합의 최소값을 구하는 문제

가장 먼저 치킨집의 좌표값을 가지는 RC 클래스를 선언하였고, 치킨집의 좌표를 저장할 list를 선언하였다.

조합을 통해 치킨집 중에서 M개를 뽑아, 모든 집에서 각 치킨집까지의 거리 중 가장 짧은 것을 새로운 배열을 만들어 해당 집 위치에 저장하였다.

모든 집에서 치킨집까지 거리의 최소값을 구하고 다 더하였다. 이 과정은 모든 조합에 대해 실시하여 가장 작은 값을 출력하는 것으로 풀이하였다.

## 16927 - 배열 돌리기 2

22.09.18 풀이

배열의 각 layer별로 반시계 방향으로 R번 돌린 결과를 출력하는 문제

각 layer별로 갯수가 다르기 때문에, 각 layer별로 돌리는 작업을 따로 해줘야한다.

각 layer별로 좌측 상단부터 시계방향으로 차례대로 Queue만들어 넣었다.

그리고 R을 layer의 갯수로 나눈 나머지 만큼 Queue에서 빼고 다시 넣는 작업을 반복하였다.

그리고 다시 좌측 상단부터 시계 방향으로 Queue에서 차례대로 꺼내 넣어주는 것을 통해 배열 돌리기를 완성하였다.

## 17070 - 파이프 옮기기 1

22.09.20 풀이

파이프를 왼쪽 위에서 오른쪽 아래까지 옮기는 경우의 수를 구하는 문제

DP를 이용하여 풀이하였다.

각 지점 별로 파이프의 오른쪽 부분이 위치할 수 있는 경우는 세가지, 가로, 세로, 대각선 형태이다.

가로로 존재하게 되는 경우는, 왼쪽칸에서 대각선 형태 + 가로 형태

세로로 존재하게 되는 경우는, 위쪽칸에서 대각선 형태 + 세로 형태

대각선으로 존재하게 되는 경우는, 왼쪽 위칸에서 대각선 + 가로 + 세로

위 세가지 관계를 바탕으로 DP칸을 채워나가게 되었다.

추가적으로 고려해야하는 상황은 벽으로 표시된 곳. 벽으로 표시된 곳은 파이프가 존재할 수 없으므로 {0, 0, 0}으로 만들어 주었고

왼쪽이나 위쪽에 벽이 존재하는 경우에는 대각선으로 존재할 수 없으므로 대각선의 경우의 수를 0으로 만들어 주었다.