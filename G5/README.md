# BOJ_G5
백준 온라인 저지 gold 5 난이도 문제풀이입니다.

---

## 1107 - 리모컨

22.10.07 풀이

리모컨에서 고장 난 버튼이 주어지고, 원하는 채널이 나온다. 원하는 채널까지 고장난 버튼을 누르지 않고 최소한의 버튼을 누르고 도달 할 수 있는지 출력하는 문제

완전 탐색으로 풀이하였다.

두가지 메소드를 만들어 사용하였다.

1. 해당 숫자를 누를 수 있는 수인지 판단

2. 해당 숫자에서 원하는 숫자까지 가는데 버튼을 몇 번 눌러야하는지

두가지 메소드를 0부터 100만까지의 모든 수에 대해 적용하여, 그 중에서 가장 작은 값을 출력하는 것으로 풀이하였다.

## 2096 - 내려가기

22.10.06 풀이

N x 3 크기의 배열이 주어지고, 가장 위부터 내려가게 되는데, 인접한 칸으로만 이동이 가능하다고 할 때, 가장 큰 값을 갖게 되는 경우와 가장 작은 값을 갖게 되는 경우를 구하는 문제

DP를 이용하여 풀이하였다.

최대와 최소를 각각 구해야하기 때문에, DP배열을 두 개 만들어 사용하였다.

그리고 DP를 채워나가는 방식은, 아래에서부터 거슬러 올라가는 방식을 이용하였다.

아래에서부터, 해당칸으로 이동할 수 있는 칸들 중에서 최대 혹은 최소를 구해, 해당칸의 값을 더해주는 방식으로 거슬러 올라가는 것으로 풀이하였다.

## 2293 - 동전 1

22.08.23 풀이

n가지의 동전의 단위가 각각 주어지고, 금액 k원이 주어진다. n가지의 동전을 가지고 k원을 표현하는 경우의 수를 구하는 문제

DP를 활용한 문제. k원이 목표이기 때문에 0원부터 시작하는 k+1 길이의 dp배열을 생성한다.

조합은 같고 순서는 다른 경우, 같은 경우의 수로 취급하기 때문에 각각의 단위 화폐부터 고려해야 중복을 피할 수 있다.

각 화폐의 단위별로 dp배열을 채우는 방식으로 진행하면 된다.

> 생각해야 하는 점

dp배열을 무조건적으로 채우려고 바깥쪽 for문을 dp를 사용하기 보다 여러 조건에 대해 dp배열을 여러번 채우는 방식도 생각해 볼 수 있다.

## 2294 - 동전 2

22.08.23 풀이

위 동전 1과 비슷한 문제지만, 이번에는 목표한 가격을 채우기 위한 최소한의 동전 갯수는 출력하는 문제

최소 갯수만 구하면 되는 것이기 때문에, 순서가 다르게 중복되는 경우는 상관이 없다.

따라서, 각 dp 값을 순차적으로 구해주면서, 해당 칸에서 각 화폐의 단위별로 이전 칸의 dp값 중 최소값에 1을 더해주는 것으로 dp배열을 채워나갔다.

## 5014 - 스타트링크

22.10.05 풀이

F층까지 있는 건물에서 S층에서 출발하여 G층까지 이동하는데, U층 위로 올라가거나, D층 아래로만 이동할 수 있다고 할 때, 최소 몇 번 이동해야하는 지 출력하는 문제

BFS로 풀이하였다.

F+1 길이의 boolean배열을 통해 방문처리에 사용하였다.

BFS 과정은 현재 층에서 U층 위로 올라간 층이 F보다 작은 경우와 D층 내려간 층이 0보다 큰 경우에만 방문하였다.

BFS가 끝났을 때, G층에 도달 했다면 그 횟수를 출력하고, G층에 도달하지 못했다면, use the stairs를 출력하였다.

## 7576 - 토마토

22.09.27 풀이

N x M 크기의 토마토 농장에 익은 토마토의 위치와 벽의 위치가 주어질 때, 하루에 한 칸씩 옆에 있는 토마토를 익게 한다. 토마토 농장이 익은 토마토로 가득차는 데까지 걸리는 시간을 구하는 문제

bfs 기본이 되는 문제이다.

맨 처음 입력을 받으면서 1의 좌표를 bfs에 이용할 queue에 미리 다 넣어두었고, 벽의 경우엔 이미 방문한 것으로 처리하였다.

좌표를 저장하면서 익는데 걸린 날을 같이 저장하는 것을 통해서 queue에서 꺼낼 때, 현재 날짜 보다 더 늦은 날짜가 있다면 해당 날짜를 저장하는 방식으로 풀이하였다.

bfs를 마친 뒤, 아직 방문처리가 되지 않은 칸이 있다면 불가능한 것으로 판단하고 -1을 출력하였다.

## 9251 - LCS

22.10.06 풀이

가장 긴 공통 부분 수열의 길이를 찾는 문제

LCS를 DP방식으로 구하였다.

LCS(X, Y)는 X와 Y의 각 마지막 글자가 같은 경우와, 같지 않은 경우로 나뉜다.

두 글자가 다른 경우에는 X에서 한 글자를 지워도 LCS에는 영향을 주지 않고, 반대로 Y에서 한 글자를 지워도 LCS에는 영향을 주지 않는다.

두 글자가 같은 경우에는 양쪽에서 그 한 글자를 지우고, 나머지 LCS에서 한글자를 더한 것과 같아진다.

위 규칙을 바탕으로 계속해서 작은 부분으로 나눠가면, 길이 1부터 비교해가면서, DP를 통해서 LCS를 구할 수 있게 된다.

## 12865 - 평범한 배낭

22.08.25 풀이

배낭에 주어진 무게를 넘지 않도록 물건을 담으려고 할 때, 각 물건의 무게와 만족도가 주어진다. 배낭에 물건들을 담아 얻을 수 있는 최대 만족도를 구하는 문제

DP를 이용하여 풀이하였다.

비슷한 문제들이 있었지만, 이번 문제에서의 핵심은 물건의 반복 사용이 불가하다는 것이었다.

기존처럼 DP배열을 0부터 차례대로 채울 경우, 한 물건이 여러번 들어가게 되어 정확한 답을 얻을 수 없었다.

이를 해결하기 위해서, DP 배열을 뒤부터 채우는 방식을 채택하였다. 

앞쪽부터 채우게 되면 이번 물건이 시행한 칸에 대해 다시 한 번 더해주게 되는 반면, 뒤쪽부터 채우게 되면, 이번 물건에서 시행한 칸이 다음 시행에 영향을 주지 않아, 한 물건을 여러번 사용하게 되는 오류를 피할 수 있다.

## 14503 - 로봇 청소기

22.09.20 풀이

1이 벽 0이 바닥으로 이루어진 공간이 주어지고, 로봇 청소기가 움직이는 규칙에 따라 청소를 한다고 할 때, 로봇 청소기가 몇 칸을 청소하였는 지 출력하는 문제.

문제에 주어진 규칙대로 코드를 작성하여 풀이하였다.

그 과정에서 청소를 한 곳은 벽과 구분하기 위하여 2로 표시하였다. 

델타 이동을 이용하여 풀이하였다.

## 15686 - 치킨 배달

22.08.29 풀이

N x N 좌표에 1은 집, 2는 치킨집으로 표시된다. 치킨집 중에서 M개만 뽑아 남기고 나머지는 없앤다고 했을 때, 각 집에서 가장 가까운 치킨집까지의 거리 합의 최소값을 구하는 문제

가장 먼저 치킨집의 좌표값을 가지는 RC 클래스를 선언하였고, 치킨집의 좌표를 저장할 list를 선언하였다.

조합을 통해 치킨집 중에서 M개를 뽑아, 모든 집에서 각 치킨집까지의 거리 중 가장 짧은 것을 새로운 배열을 만들어 해당 집 위치에 저장하였다.

모든 집에서 치킨집까지 거리의 최소값을 구하고 다 더하였다. 이 과정은 모든 조합에 대해 실시하여 가장 작은 값을 출력하는 것으로 풀이하였다.

## 16927 - 배열 돌리기 2

22.09.18 풀이

배열의 각 layer별로 반시계 방향으로 R번 돌린 결과를 출력하는 문제

각 layer별로 갯수가 다르기 때문에, 각 layer별로 돌리는 작업을 따로 해줘야한다.

각 layer별로 좌측 상단부터 시계방향으로 차례대로 Queue만들어 넣었다.

그리고 R을 layer의 갯수로 나눈 나머지 만큼 Queue에서 빼고 다시 넣는 작업을 반복하였다.

그리고 다시 좌측 상단부터 시계 방향으로 Queue에서 차례대로 꺼내 넣어주는 것을 통해 배열 돌리기를 완성하였다.

## 17070 - 파이프 옮기기 1

22.09.20 풀이

파이프를 왼쪽 위에서 오른쪽 아래까지 옮기는 경우의 수를 구하는 문제

DP를 이용하여 풀이하였다.

각 지점 별로 파이프의 오른쪽 부분이 위치할 수 있는 경우는 세가지, 가로, 세로, 대각선 형태이다.

가로로 존재하게 되는 경우는, 왼쪽칸에서 대각선 형태 + 가로 형태

세로로 존재하게 되는 경우는, 위쪽칸에서 대각선 형태 + 세로 형태

대각선으로 존재하게 되는 경우는, 왼쪽 위칸에서 대각선 + 가로 + 세로

위 세가지 관계를 바탕으로 DP칸을 채워나가게 되었다.

추가적으로 고려해야하는 상황은 벽으로 표시된 곳. 벽으로 표시된 곳은 파이프가 존재할 수 없으므로 {0, 0, 0}으로 만들어 주었고

왼쪽이나 위쪽에 벽이 존재하는 경우에는 대각선으로 존재할 수 없으므로 대각선의 경우의 수를 0으로 만들어 주었다.

## 20055 - 컨베이어 벨트 위의 로봇

22.10.07 풀이

컨베이어 벨트위에 로봇이 있다. 컨베이어 벨트가 이동하는 방향으로, 로봇이 이동할 수 있다고 할 때, 내구도가 기준을 넘어서면 멈출 때, 몇번의 반복을 시행했는 지 출력하는 문제

문제에서 주어진 조건을 그대로 구현하였다.

컨베이어 Belt 클래스를 만들어 사용하였다.

Belt클래스는 링크스 리스트 처럼 앞뒤로 연결되도록 하였고, 해당 칸의 내구도와 위에 로봇이 올려져있는 지에 대한 정보가 있다.

올리는 위치와 내리는 위치에 대한 포인터를 지정하였고, 컨베이어 벨트가 이동하는 것을 해당 포인터가 앞으로 한칸씩 이동한다고 표현하였다.