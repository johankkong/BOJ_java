# BOJ_S4
백준 온라인 저지 silver 4 난이도 문제풀이입니다.

---

## 1018 - 체스판 다시 칠하기

22.09.15 풀이

B와 W가 섞여서 N x M 크기를 채우고 있다고 할 때, 그 중 8 x 8 을 잘라, 체스판을 만든다면 최소한 몇 칸을 바꿔야 체스판이 성립하는 지 구하는 문제

가능한 모든 부분에 대하여, 체스판을 만들려면 몇 칸을 바꿔야하는 지 계산하여 가장 작은 수를 출력한다.

체스판이 가능한 경우는 두 가지, 오른쪽 위가 B인 경우와 W인 경우이다.

두 가지 경우에 대해 각각 메소드를 만들어 모든 칸에 대해 두 가지 경우의 수를 모두 계산하는 방법으로 풀이하였다.

## 1158 - 요세푸스 문제

22.08.18 풀이

요세푸스 수열을 출력하는 문제. 1부터 N까지의 수가 있다고 할 때, 연속적으로 K번 째 수를 제외해나간다고 할 때, 제외되는 순서대로 출력하는 문제

Node클래스와 Node 객체들을 연결해주는 LinkedList클래스를 만들어 풀이하였다.

Singly Linked List 방식으로  한 방향으로 연결되는 클래스를 구현하였고, 마지막 tail의 next가 head로 연결되는 순환형 리스트로 만들었다.

Node가 하나 남을 때까지, 지속적으로 Node를 제거해가며 StirngBuilder에 더해주었고 하나가 남았을 때까지 반복하였다.

하나가 남았을 때 해당 Node의 data를 마지막으로 더해주는 것으로 풀이하였다.

## 2164 - 카드2

22.08.18 풀이

N장의 카드가 있을 때, 1번카드가 가장 위, N번카드가 가장 아래 있다고 할 때, 맨 위 카드를 버리고 그 다음 카드를 맨 밑으로 이동시키는 과정을 반복한다고 하자. 마지막에 남은 카드를 출력하는 문제.

전형적인 Queue를 이용하는 문제이다. 1번부터 N번까지 순서대로 Queue에 집어넣고, 한장 `poll()`로 버리고, 그 다음 카드는 `offer(poll())` 메소드를 통해 맨 밑에 넣는 과저을 반복한다.

카드가 한장 남을 때까지 반복하고, 그 한 장 남은 카드를 출력하는 방식으로 풀이하였다.

## 2491 - 수열

자연수 N 과 길이 N의 수열을 입력받는다. 감소하거나 증가하는 구간의 최대 길이를 출력하는 문제

수열을 길이 N의 1차원 배열로 입력받아, 두번의 탐색을 통해 구간의 최대 길이를 구하였다. 

첫번째는 증가하는 구간을 계산하는 탐색이었고

두번째는 감소하는 구간을 계산하는 탐색이었다.

두번의 탐색 중 가장 긴 구간의 길이를 출력하는 것으로 풀이하였다.

> 다른 방법 시도

수열의 숫자들을 하나하나 입력받으며 하나씩 입력받을 때마다 증가하는 지 감소하는 지 판단하여 구간을 계산하고자 하였다.

하지만, 증가하는 구간과 감소하는 구간이 겹치는, 같은 숫자가 연속으로 나오는 구간에 대해 판단하기 어려웠다.

## 2567 - 색종이 - 2

22.08.10 풀이

100 x 100 흰색 도화지에 n개의 10 x 10 검정 색종이를 각 변이 평행하게 붙인다.
색종이를 모두 붙인 뒤, 생기는 모든 경계선의 길이를 출력하는 문제

100 x 100 2차원 배열을 boolean 배열로 만들어, 색종이가 붙는 부분만 true 로 초기화를 해주었다.

그리고 현재 상태를 나타내는 flag 변수를 false로 초기화하고, 각 행과 열을 탐색하면서 flag의 상태가 바뀔때마다 경계선이기 때문에 result 변수에 1을 더해 주었다. 

각 행과 열이 끝날때마다 flag 변수를 false로 전환해주는데 만약 true가 저장되어 있다면, result에 1을 더하는 방식으로 풀이하였다. 

## 2578 - 빙고

5 x 5 크기의 빙고를 진행하면서, 몇 번째 수가 불렸을 때 빙고 세줄이 완성되는 지 출력하는 문제

빙고 수들을 5 x 5 크기의 2차원 배열로 입력받고, 각 행과 열의 X표 갯수를 넣을 길이 5의 1차원 배열 2개, 그리고 두 대각선의 X표 갯수를 저장할 길이 2 배열을 선언하였다.

그리고 수를 입력 받을 때마다, 해당 행과 열을 찾아 행과 열의 X표 배열에 1씩 추가하고 대각선인 경우, 대각선의 배열에도 1을 추가한다.

1을 추가할 때마다 해당 줄에 X표가 5개가 되었는지 확인하고 5개가 되었다면 빙고 갯수를 추가한다.

빙고갯수가 3개이상이 되면 입력 받는 것을 멈추고, 해당 숫자가 몇번째로 불렸는지 출력하는 것으로 풀이하였다.

## 10157 - 자리배정

22.08.09 풀이

콘서트에 오는 사람들의 자리배정을 (1,1)부터 시계방향으로 차례대로 배정한다. 가로와 세로의 길이가 주어지고, n번째 오는 사람이 배정받는 자리의 좌표를 출력하는 문제

입력받은 가로와 세로 크기의 2차원배열을 생성하고, 델타이동 방법을 활용하여 경계선을 만나거나, 이미 1이 채워진 칸을 만나면 방향을 전환하는 방식으로 풀이를 하였다.

> 어려웠던 점

경계선을 넘어가는 경우를 반드시 고려해줘야한다. 아니면 OutOfBoundsException이 발생한다.

순환적인 델타이동을 할 때엔, `d = ++d % 4` 이용할 수 있다.

왼쪽아래가 (1,1)인 `x``y`좌표와 달리 2차원 `배열[r][c]`은 왼쪽 위가 (0,0)이기때문에 변환하는 데에 어려움이 있었다. 
- x는 c+1 이었고 y는 세로길이-r 로 변환하였다.

## 10158 - 개미

22.08.11 풀이

크기가 주어지는 직사각형 종이위에 개미가 있다고 할때, 시작 좌표와 t만큼 대각선 한칸을 움직인다고 하자. 경계선에 도달할 경우, 빛의 반사처럼 움직인다고 할 때, t시간 후에 개미의 위치를 출력하는 문제

x좌표와 y좌표를 따로 계산하는 방식으로 풀이하였다.

두 좌표 모두, 각각 너비와 높이로 나누는 것을 통해 구할 수 있다.

x좌표 기준으로 너비로 나눈 몫이 짝수라면, 그 나머지가 곧 최종적인 x좌표가 되고, 나머지가 0일때는 0이 된다.

반대로 너비로 나눈 몫이 홀수라면, 한번 충돌이 있었기 때문에, 너비에서 나머지를 뺀 값이 x좌표가 된다. 이때, 나머지가 0인 경우엔 너비가 곧 x좌표가 된다. 

y좌표에 대해서도 동일한 방식으로 풀이하였다.

> 생각해볼 것

원래는 t동안 for문을 돌리며, 충돌이 일어날 때 각 좌표의 방향을 바꾸는 식으로 풀이하려고 하였으나, t가 너무 커짐에 따라 시간 초과가 나와 풀이 방법을 변경하였다.

t를 높이와 너비에 맞게 줄이는 방법이 있다면 좋을 것이다.

## 10845 - 큐

22.08.19 풀이

정수를 저장하는 큐를 구현하여, 문자열 입력으로 각 기능들이 수행되는 것을 출력하는 문제

java 기본 api의 큐를 이용하여 바로 풀이하였다.

각 실행 별로 그때그때 출력을 해줄 경우, 시간 초과가 나오기 쉽기 때문에, `StringBuilder`를 이용하여 마지막에 한번에 출력해주었다.

## 12789 - 도키도키 간식드리미

22.08.22 풀이

번호표를 가지고 무작위순서로 줄서있는 사람들이 있다고 할 때, 자기차례가 아닌 경우, 옆으로 비킬수 있지만 뒤에 있는 사람이 먼저 올 수는 없다고 한다. 주어진 순서대로 차례가 아닌 사람들이 비켜가면서 모두 들어갈 수 있는 지 판단하는 문제

배열로 사람들의 번호를 입력 받았고, 현재 들어갈 차례의 번호를 cnt 변수로 추적하였다.

배열의 값들을 하나씩 확인하면서 cnt와 일찍하는 경우 넘어가고 일치하지 않는다면, stack에 넣는 방식으로 풀이하였다.

이과정에서 cnt와 일치하지 않는 경우, stack.peek()가 들어갈 차례인지 확인하여 들어갈 차례라면 pop()을 하고 i--를 통해 해당 칸에 대해 다시한번 판단하는 것이 주요했다.
 