# BOJ_G2
백준 온라인 저지 gold 2 난이도 문제풀이입니다.

---

## 1167 - 트리의 지름

22.11.13 풀이

트리를 구성하는 정점과 간선의 가중치가 주어질 때, 해당 트리의 지름을 구하는 문제

트리의 지름이란, 트리 내의 임의의 두 정점 사이를 잇는 간선들의 가중치 합의 최대치를 의미한다.

트리의 지름을 구하는 방법은, 임의의 한점에서 가장 먼 정점을 구하고, 해당 정점에서 다시 가장 먼 정점을 구했을 때, 그 두 정점 사이의 가중치 합이 해당 트리의 지름이다.

위 방식을 그대로 적용하여 풀이하였다.

각각 가장 먼 정점을 구하는 것은 dfs를 통해서 구하였다.

## 1655 - 가운데를 말해요

22.10.06 풀이

숫자를 입력 받을 때마다, 지금까지 입력 받은 수들 중에서 중간값을 출력하는 문제

입력을 받을 때마다 List혹은 배열에 넣고 매번 정렬을 해주면, 시간 초과가 발생할 것이 뻔했다.

따라서, 내부적으로 자동적으로 정렬을 해주는 자료구조가 필요했고, PriorityQueue를 사용하였다.

일반적인 PQ 하나만 사용할 경우, 중간에 들어가 있는 중간값에 접근하기가 어려웠기 때문에

PQ 2개를 사용하여, 하나는 순서를 반대로 정렬하였다.

중간값을 추적하면서, 더 큰값은 오른쪽 PQ에 더 작은 값은 왼쪽 PQ에 넣으면서 양쪽의 size()를 맞춰주면서 풀이하였다.

## 1918 - 후위 표기식

22.09.20 풀이

주어진 식을 입력받아 후위 표기식으로 변환하여 출력하는 문제

문자열로 입력받아 앞에서부터 한 글자씩 읽어 나간다.

연산자가 아닌 경우, 바로 출력하고

연산자의 경우, (는 무조건 stack에 넣고, )를 만난 경우, (가 나올 때까지 stack에서 뽑으며 출력한다.

나머지 연산자의 경우, ( : 0, +, - : 1, *, / : 2의 우선순위를 부여하여 자신보다 낮은 우선순위가 맨 위에 올 때까지 stack에서 뽑아 출력한다.

이 때, 우선순위를 비교하기 위하여 Map을 이용하였다.

문자열을 끝까지 위와 같은 규칙으로 읽은 뒤, stack에 남아있는 것을 모두 뽑아 출력하면 된다.

## 12100 - 2048 (Easy)

22.10.22 풀이

2048 게임의 규칙에 따라 최대 5회 까지 이동할 수 있다고 할 때, 이동 후 배열에 남아있는 값들 중 최대값을 구하는 문제

상하좌우의 방향을 중복을 허용하여 길이 5의 순열을 만들었다.

모든 순열에 대해서, 그 순서 대로 이동을 진행하였고, 이동을 완료한 후에 최대값을 찾는 것을 반복하였다.

이동하는 과정은, 이동하려는 방향에서부터, 0이 아닌 값을 저장하고, 그 다음 값이 이전 값과 같다면 합치고, 아니면 이전 값을 맨앞에 저장하는 것을 반복하여 풀이하였다.

## 17136 - 색종이 붙이기

22.11.09 풀이

한변의 길이가 1부터 5까지의 색종이를 최대 5개씩만 사용면서, 표시된 부분을 모두 채운다면, 최소 몇 개로 채울 수 있는 지 구하는 문제

dfs를 이용하여 풀이하였다. 가장 큰 사이즈의 종이부터 붙여가면서, 가능한 모든 종이를 붙여보는 방식으로 풀이하였다. 

처음엔 탐색을 통해서, 1을 찾아나가면서 dfs를 실행했지만, 그렇게 풀이할 경우, 너무 많은 탐색이 발생하여 시간초과가 발생한다.

따라서, dfs에 각 칸을 지정해주는 것을 통해서 풀이하였다.

## 17143 - 낚시왕

22.10.21 풀이

상어들의 위치와 움직임, 사람의 위치와 낚시 지점이 주어질 때, 사람이 낚시를 완료하고 낚시한 상어의 무게의 합을 구하는 문제

행, 열, 속도, 방향, 무게의 정보를 가지는 상어 클래스를 만들어 사용하였다.

2차원 배열을 만들어 위치를 표시하는 방법을 사용하지 않고, 모든 상어의 정보를 저장하는 List를 만들어 사용하였다.

해당 List를 열, 행, 무게 순으로 정렬하였다.

사람이 존재하는 열의 가장 작은 행에 있는 상어를 잡는 것으로 구현하였고, 행과 열이 같은 경우, 가장 마지막에 있는 상어가 가장 무거운 상어이기 때문에, 해당 상어만 남기고 나머지 상어는 List에서 삭제하는 방식을 이용하였다.

## 19237 - 어른 상어

22.11.07 풀이

상어들이 냄새를 뿌리면서 이동하는데, 동일한 위치에 위치하는 경우, 더 작은 수의 상어가 남는다고 할 때, 1번의 상어만 남는데까지 걸리는 시간을 구하는 문제

상어 클래스와 냄새 클래스는 만들어 저장하였다.

상어들은 배열에 표시하지 않고, list에 저장하는 것으로 추적하였다.

냄새들이 존재하는 정보는 냄새 2차원 배열을 만들어 추적하였다.

놓쳤던 부분은 먼저 모든 상어가 냄새를 뿌리고 이동을 시작해야하는데, 한마리씩 냄새를 뿌리고 이동하려고 해서 틀렸었다.

## 19238 - 스타트 택시

22.10.19 풀이

택시가 시작 지점에서 가장 가까운 승객을 태우고, 해당 승객의 목적지로 이동한다. 한칸에 연료가 1 사용되는데, 0보다 떨어지면, 영업을 종료한다.

모든 승객을 완료하고 남은 연료를 구하는 문제.

현재 택시의 위치에서 bfs를 통해서 가장 가까운 승객을 찾습니다. 거리가 같은 승객 중 가장 위, 왼쪽에 있는 승객을 태워야하기 때문에 PriorityQueue를 사용하여 정렬하였습니다.

승객을 태웠다면, 다시 목적지로 향하는 bfs를 사용하였습니다.

승객 혹은 목적지에 도달할 때마다, 연료에서 거리를 빼주었고, 0보다 작아진다면 그 즉시, 탐색을 멈추는 방법을 사용하였습니다.

현재 택시가 승객에게 도달할 수 없거나, 승객을 태운뒤, 목적지로 도달할 수 없는 경우를 처리하는 것이 필요합니다.

그렇지 않을 경우, 무한 루프가 발생할 수 있습니다.