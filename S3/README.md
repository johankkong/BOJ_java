# BOJ_S3
백준 온라인 저지 silver 3 난이도 문제풀이입니다.

---

## 1003 - 피보나치 함수

22.09.01 풀이

피보나치 함수에서 특정 수를 실행시켰을 때, 0과 1이 각각 몇번 호출되는지 구하는 문제.

피보나치 함수를 구현하여 횟수를 세면, 시간초과가 나오기 때문에 DP를 이용한다.

n에서 1이 호출되는 횟수는 n-1과 n-2에서 1이 호출되는 횟수를 더한 값이다.

같은 방식으로 0이 호출되는 횟수도 n-1과 n-2에서 0이 호출되는 횟수를 더한 값이다.

위 규칙을 이용하여, 41 x 2 크기의 2차원 배열 DP를 선언하여 풀이하였다.

## 1244 - 스위치 켜고 끄기

n개의 스위치가 있다. 남학생과 여학생이 각각 숫자를 받게 되는데, 남학생의 경우 받은 숫자의 배수 위치의 스위치를 켜고 끈다. 여학생의 경우, 받은 숫자를 기준으로 스위치의 상대가 대칭인 범위만큼 스위치를 전환한다.

남학생의 경우, 받은 숫자의 배수의 스위치만 전환해주면된다.

여학생의 경우, 먼저 받은 숫자의 스위치를 전환하고, 한칸씩 탐색하며 대칭인지 확인하고 대칭인 경우에 스위치를 전환한다. 이 때, 배열 밖으로 벗어나는 경우를 제외시켜 주는 것이 중요하다.

> 보완할 점

나는 1과 0을 전환하는 메소드를 만들어 사용했지만, 간단하게 `arr[i] = 1 - arr[i]`를 사용해주면 더 효율적이다.

## 1463 - 1로 만들기

입력으로 주어지는 자연수를 1 빼기, 2의 배수라면 2로 나누기, 3의 배수라면 3으로 나누기. 이 세가지 연산을 순서 상관없이 반복적으로 사용하여 1을 만드는 최소 연산 횟수를 구하는 문제

현재의 값과 연산에 사용된 횟수를 저장하는 클래스 `Node`를 만들어 사용하였다.

bfs(너비 우선 탐색) 방식으로 해당 수에서 가능한 연산을 진행한 뒤 Node를 만들어 Queue에 넣고, Queue에서 하나씩 빼오면서 연산을 진행하고 연산 진행 횟수를 업데이트 해주면서, 1이 되면 bfs를 중단하는 방식으로 풀이하였다.   

## 2108 - 통계학

22.08.11 풀이

숫자들을 입력받아 그 숫자조합의 산술평균, 중앙값, 최빈값, 범위를 출력하는 문제

1. 산술평균의 경우, 값을 모두 더해 숫자의 수로 나누어 `Math.round()` 메소드로 반올림해주었다.

2. 중앙값의 경우, 배열로 입력받아 `Array.sort()` 메소드를 통해 오름차순으로 정리하고 중앙값을 출력하였다.

3. 최빈값의 경우, 숫자들을 각 Key로 하고 등장하는 횟수를 value로 하는 Map에 저장하여 횟수를 세었다. 

그리고, 이 Map의 Entry를 요소로 가지는 List를 `map.entrySet()`메소드를 통해 LinkedList로 생성하였다.

이러한 List를 정렬하는 과정에서 comparator를 재정의하여 value기준으로 먼저 정렬하고 value가 같다면 key값을 내림차순으로 정렬하도록 하였다.

그리고 최빈값이 하나인경우, 그 최빈값을 출력하고, 최빈값이 2개 이상인 경우, 두번째로 작은 값을 출력하였다.

4. 범위의 경우, 숫자들의 배열을 이미 정렬해두었기 때문에 가장 작은 값과 가장 큰 값을 빼주면 되었다. 이때, 숫자가 1개만 있다면 0을 출력하도록 해야했다.

## 2477 - 참외밭

22.08.11 풀이

가로 세로 변으로만 이루어진 6각형의 넓이를 구하는 문제. 

가로 세로변으로만 이루어졌기 때문에, 큰 직사각형에서 작은 직사각형을 빼는 것으로 면적을 구하는 것이 가능하다. 

각 변의 길이가 인접한 순서대로 주어지기 때문에, 가로중에 가장 긴 변과 세로중에 가장 긴 변은 맞닿아 있다.

또한, 가장 긴 두변에서 반대방향으로 2칸씩 이동하면 작은 직사각형의 가로세로에 접근할 수 있습니다.

따라서, 가로 세로 별로 각각 가장 긴 변의 인덱스를 구하고, 작은 인덱스에서 2를 빼고 큰 인덱스에서 2를 더하는 방식으로 작은 직사각형을 찾았다.

이때, 가장 긴 두 변의 인덱스가 0과 5인 경우, 최대 최소로 접근하기가 어려웠고, 이 경우만 따로 코드를 작성해 주었다.

## 2559 - 수열

숫자의 갯수와 길이를 입력받고, 숫자의 갯수만큼의 수를 입력받는다. 그리고 길이만큼의 범위의 숫자를 모두 더한 값 중 가장 큰 수를 출력하는 문제.

숫자들을 배열로 입력받아 길이만큼 더하면서 max 변수와 비교하고 max보다 큰 경우 max에 그 값을 저장하는 방식으로 풀이하였다.

이 과정에서 2중 for문을 사용하였다.

## 2579 - 계단 오르기

계단의 수와 계단에 적혀있는 숫자가 주어질 때, 한칸씩 오르거나 두칸씩 올라 밟은 숫자의 최대값을 구하는 문제. 단, 이때, 연속된 세개의 계단을 오를 수 없다.

모든 경우의 수를 계산하여, 최댓값을 구하려고 하는 경우, 시간초과가 나온다.

따라서 큰 문제를 작은 문제로 나누어 단계적으로 계산하는 동적 계획법(DP)을 이용하였다.

계단의 숫자를 입력받을 1차원 배열을 만들어, 각 숫자를 입력받는다.

각칸에 대해 세가지 상황에 따른 최댓값을 저장할 3 x 계산수 크기의 2차원 배열을 생성하였다.

각 칸이 가질 수 있는 상황은 
1. 두칸 뛰어서 도착
2. 한칸 뛰어서 도착
3. 건너뛰기

세 가지 이다.

두칸 뛰어서 도착의 경우, 이전 칸의 건너뛰기에 현재 계산 숫자를 더하고, 한칸 뛰어서 도착의 경우, 이전 칸에 두칸 뛰어서 도착한 수에 현재 계산 숫자를 더한다.

마지막으로 건너뛰기의 경우, 이전칸의 건너뛰기를 제외한 1, 2 중 더 큰 값을 저장한다. 

이러한 규칙으로 최고 높이의 계단까지 도착하여, 1과 2중의 최대값을 계산하여 출력하였다.

## 9095 - 1, 2, 3 더하기

22.10.06 풀이

11이하의 자연수를 입력받아, 1과2와3의 덧셈으로 해당 수를 표현할 수 있는 경우의 수를 구하는 문제

DP로 풀이하였다.

n을 표현하는 방법은
1. n-1을 표현하는 방법
2. n-2를 표현하는 방법
3. n-3을 표현하는 방법

세가지를 더하면 된다.

## 10972 - 다음 순열

22.09.20 풀이

주어진 순열에서 다음으로 큰 순열을 출력하는 문제

다음 순열을 구하는 과정은 다음과 같다.

1. 가장 오른쪽부터 증가하며 가장 큰 위치를 찾는다. : A

2. 가장 큰 위치의 오른쪽 위치를 찾는다. : B

3. 가장 오른쪽부터 B보다 처음으로 큰 수를 찾는다. : C

4. B와 C를 교환한다.

5. 가장 오른쪽부터 A까지를 뒤집는다.

위 과정을 코드로 만들어 풀이하였다.

## 17413 - 단어 뒤집기 2

문자열을 입력받아 <>괄호 안에 있는 문자들은 그대로 두고, 괄호 밖에 있는 문자들은 단어 단위로 뒤집어 출력하는 문제

가장 중요한 아이디어 두개는 StringBuilder를 사용한 문자열 만들기와 stack을 이용한 문자 뒤집기이다.

시작 괄호 < 를 만나면 flag를 true를 만들어, flag가 true인 동안엔 sb에 바로 append해준다.

끝나는 괄호 > 를 만나면 flag를 false로 만들어, 그 이후 문자들은 괄호 밖의 문자 임을 알려준다.

flag가 false인 상태에서 문자가 들어온다면 해당 문자들은 단어 단위로 뒤집어야하기 때문에 stack에 차례대로 넣어준다.

공백을 만나면 stack에 있는 문자들을 차례대로 sb에 append해주는 것을 통해 단어단위로 뒤집을 수 있다.

문자열이 끝나거나, < 시작 괄호를 만났을 때 stack에 문자가 들어있다면 꺼내주는 것을 잊지 말자.

마지막으로 sb를 출력하는 것으로 풀이를 완료하였다.