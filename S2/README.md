# BOJ_S2
백준 온라인 저지 silver 2 난이도 문제풀이입니다.

---

## 1654 - 랜선 자르기

22.09.21 풀이

주어진 K개의 랜선을 잘라 N개로 만든다고 할 때, 그 최대 길이를 구하는 문제.

1부터 시작하여 모든 자연수에 대하여 그 결과를 본다면, 시간초과가 발생한다.

이진탐색을 이용하여 풀이하였다.

1부터 랜선의 길이 중 가장 긴 길이를 최대로 두고 이진 탐색을 진행, N개보다 많은 수가 나온다면 길이가 더 긴 쪽으로, 더 적은 수가 나온 다면 길이가 짧은 쪽을 탐색하도록 하였다.

> 주의해야 할 점

이 문제에서 랜선의 길이가 int자료형의 최대값까지 가능하다고 했기 때문에, 이진탐색에서 mid를 구하는 과정에 양쪽을 더하고 2로 나누는 과정에서 int자료형의 범위를 벗어나는 경우가 생겼다.

따라서, mid = (left + right) / 2 를 사용할 수 없고

mid = (int)(((long)left + (long)right)) / 2); 로 작성하거나

mid = left + (right - left) / 2; 로 작성하여야했다.

## 1874 - 스택 수열

22.09.22 풀이

1부터 차례대로 stack에 push가 가능하다고 할 때, pop을 통해서 주어진 수열을 만들 수 있는 지 출력하는 문제

1부터 차례대로 넣기 위해서 1부터 N까지 저장한 Queue를 이용하여 차례대로 push할 수 있도록 하였다.

수열을 차례대로 입력받으면서 두가지 조건에 부합하는 지 판단하였다.

1. 현재 Queue에 가장 앞에 있는 수(stack에 push할 차례인 수)보다 크다면 그 수가 나올 때까지 push하고 그 수만 pop한다.

2. stack의 가장 위에 있는 수와 같다면 pop한다.

위 두 가지 조건에 부합하지 않는다면, 해당 수열은 만들 수 없는 수열이므로, flag를 false로 만들고 중지한다.

flag가 true로 남아 있는 경우에만, push와 pop을 한 순서대로 출력하고

false인 경우엔, NO를 출력하였다.

## 1965 - 상자넣기

22.08.19 풀이

N개의 상자들의 크기가 차례대로 주어진다. 왼쪽의 작은 상자를 오른쪽의 큰 상자에 집어 넣을 수 있다고 할 때, 왼쪽부터 차례대로 집어넣었을 때, 한 상자에 들어있을 수 있는 상자의 최댓값을 출력하는 문제

Bottom up 방식의 DP를 사용하여 풀이하였다.

첫번째 박스엔 아무것도 담을 수 없으므로 1을 저장한다.

두번째 박스부터는 앞쪽 박스들과의 크기를 비교하여, 더 작은 박스가 없을 경우 1을 저장하고, 있을 경우 작은 박스들 중 가장 큰 dp값에 1을 더하여 저장하는 방식으로 배열의 끝까지 채워넣었다.

dp배열을 채운 뒤, dp 배열 중 가장 큰 값을 출력하는 것으로 풀이하였다.

## 2304 - 창고 다각형

0부터 1000 사이의 N개의 기둥들의 위치와 높이가 주어진다. 이 기둥들을 모두 덮는 지붕을 만든다고 할때, 오목한 부분이 없도록, 최소 면적의 지붕을 계산하여 건물 단면의 면적을 출력하는 문제.

가장 높은 기둥의 높이를 먼저 구하고, 해당 높이의 기둥이 여러개 있을 경우를 대비하여, 해당 높이의 기둥 중 가장 왼쪽에 있는 기둥의 인덱스를 구하고, 해당 높이의 기둥 중 가장 오른쪽에 있는 기둥의 인덱스를 구한다.

가장 높은 기둥이 여러개 있는 경우, 가장 왼쪽 기둥과 가장 오른쪽 기둥 사이의 면적을 면적에 더해주고,

그렇지 않다면 해당 기둥의 높이를 면적에 더해준다.

그리고 왼쪽부터 1씩 인덱스를 높여가면서 자신보다 큰 기둥이 나오기 전까지 자신의 높이를 면적에 더해주고, 자신보다 큰 기둥이 나오면 해당 기둥의 높이를 면적에 더해주기 시작한다.

오른쪽도 같은 방식으로 더해준다.

위 방식을 최대 높이 기둥을 만날 때까지 반복해주면 최종면적이 나오게 된다. 

## 2615 - 오목

22.08.16 풀이

19 x 19 오목판에서 1과 2가 오목을 한다고 할 때, 진행중인 오목판이 입력으로 주어지고, 오목이 완성되었다면 승자와 함께 오목이 완성된 위치를 출력하는 문제

6목은 허용되지 않으며, 오목이 완성된 경우 가장 왼쪽의 위치를, 세로로 완성된 경우 가장 위쪽의 위치를 출력한다. 승부가 나지 않은 경우, 0을 출력한다.

각 위치에 대해 오목이 완성될 수 있는 경우는 네 가지, 우측, 우상측, 우하측, 하측.

네 방향에 대해 `int[] dr = { 0, -1, 1, 1 }; int[] dc = { 1, 1, 1, 0 };`으로 델타 이동을 잡고, 해당 칸에 대해 오목이 완성되었는지 확인하는 메소드를 작성하였다. 

이 때, 놓친 부분은 두가지. 

1. 6목을 허용하지 않기 때문에, 6번째 칸도 같은지 확인해야한다.

2. 6목을 확인하고 넘어간 경우, 두번째칸에서 다시 탐색할 때, 6목을 걸러내지 못하기 때문에 반대방향 한칸도 같은지 확인해야했다.

이 두가지를 확인하며 메소드를 작성하고 true가 나온 경우의 위치를 출력하는 것으로 풀이하였다. 

승부가 나지 않는 경우 0을 출력하는 것도 잊으면 안된다.

## 2805 - 나무 자르기

22.09.22 풀이

나무들의 길이가 주어지고, 특정 높이로 나무들을 자른다고 할 때, 그 높이 위로 잘리는 나무들의 길이의 합이 M보다 크거나 같아지는 최고 높이를 구해 출력하는 문제.

0부터 최대 나무 길이를 이진  탐색을 통해 최대 높이를 구하였다.

이진 탐색은 재귀함수를 통해 구현하였고, 그 과정에서 특정 길이로 자를 때, 얼마의 나무들이 잘리는 지 구하는 메소드로 작성하여 사용하였다.

## 3987 - 보이저 1호

22.08.25 풀이

우주공간에 "/" "\" 행성과 "C" 블랙홀이 있다고 할 때, 특정 위치에 있는 보이저 1호가 시그널을 발생시키고 행성들에 반사되며 가장 길게 시그널이 남아있는 방향과 그 길이를 출력하는 문제

델타이동을 이용하여 풀이하였다.

각 / \ 을 만나는 경우 알맞게 델타이동의 방향을 바꿔주며 그 길이를 측정하였다.

경계 내부에 있으면서 블랙홀을 만나지 않는 경우에 계속해서 돌도록 하였다. 

이때, 무한 순환을 하게 되면 voyager를 출력해야 했는데, 이 조건은 다시 출발 지점에 시작 방향과 동일한 방향으로 도달하는 것이다. 

따라서 시작 위치와 시작 방향을 저장해두어 일치하는 지 확인해가며 풀이하였다.

## 11053 - 가장 긴 증가하는 부분 수열

22.08.18 풀이

길이 N의 수열을 입력받아, 해당 수열의 부분 수열 중에서 값이 순차적으로 증가하는 부분 수열의 최대 길이를 구해 출력하는 문제

DP를 활용하여 풀이하였다.

맨 앞칸부터 해당 칸을 마지막으로하는 부분 수열의 최댓값을 저장하는 방식으로, dp배열에 저장하였다.

특정칸의 값보다 작은 값을 가지는 그 이전 칸들 중 최대 길이에 1을 더한 길이를 해당 칸의 dp배열에 저장하는 방식으로 풀이하였다.

마지막 칸까지 모두 dp배열을 채웠다면, dp배열에 저장된 값들 중 가장 큰 값을 출력한다.

## 14430 - 자원 캐기

r x c 크기의 2차원 배열이 0과 1로 채워져있다. (0, 0)에서 출발하는 기계가 오른쪽과 아래로만 이동할 수 있다고 할 때, 가장 오른쪽 아래에 도착했을 때, 기계가 지날 수 있는 1의 갯수 중 최대를 구하는 문제

DP를 활용하는 문제.

각 칸에 도달할 수 있는 방법은 왼쪽과 위쪽에서 오는 두가지 방법 뿐이다.

따라서, 각 칸에 대해 왼쪽과 위쪽 중에서 더 많은 1을 지난 경로에 현재 칸의 값을 더해주면 그 칸까지 도달하는 데에 최대값을 구할 수 있다.

단, 시작지점인 (0, 0)은 해당 칸의 값으로 시작하게 하였고,

왼쪽 경계선의 경우, 위쪽에서 오는 방법 밖에 없기 때문에 위쪽 dp값에 해당칸의 배열 값을 더해주었고,

위쪽 경계선의 경우 마찬가지로, 왼쪽에서 오는 방법밖에 없기 때문에 왼쪽 dp값에 해당칸의 배열값을 더해주었다.

위와 같은 방식으로 모든 칸에 대해 dp값을 만들어 주었고 마지막으로 가장 오른쪽 아래칸의 dp값을 출력해주는 것으로 풀이하였다.

## 14889 - 스타트와 링크

22.09.20 풀이

스타트와 링크 팀으로 나누어 두 팀의 시너지 차이를 최소화한다고 했을 때, 그 때의 시너지 차이를 구하는 문제

처음에 N명의 사람 중 N / 2명을 뽑는 조합을 시행하였다.

이 과정에서 boolean 배열을 이용하였다. 

N / 2명을 뽑을 때마다 2중 for문을 이용하여 모든 2명 조합에 대해 시너지를 팀별로 구하여, 시너지 차이의 최소를 result에 저장하는 방식으로 풀이하였다.

## 18353 - 병사 배치하기

n명의 병사들의 전투력이 각각 주어지고, 그들의 순서를 유지한다고 하며, 최소한으로 몇명만 빼면 전투력이 내림차순이 되는 지 구하는 문제

DP를 사용하였다.

첫 칸의 최대 길이는 1이 되고

그 다음 칸부터는 자신보다 앞쪽에 있는 칸들에 대해서만, 자신보다 큰 전투력을 가지는 칸을 구한다.

그 칸들 중에서 가장 높은 dp값을 가지는 칸의 dp값에 1을 더하여 자신의 dp값에 저장하면 된다.

위와 같은 방식으로 끝까지 dp배열을 채우고 dp배열 중에서 가장 큰 값을 출력하면된다.

## 23304 - 아카라카

22.08.18 풀이

문자열이 주어지고 해당 문자열이 아카라카 펠린드롬인지 확인하는 문제. 아카라카 펠린드롬이란 문자열이 펠린드롬이고, 해당 문자열을 반으로 나눠, 각각 접두사와 접미사가 모두 아카라카 펠린드롬인 것을 말한다.

회문인지 검사하는 메소드를 구혀하였고, 그 후에 재귀함수로 아카라카 펠린드롬인지 확인하는 메소드를 구현하였다.

재귀함수는 회문이 아니면 false를 반환하고 문자열의 길이가 1이 된다면 true를 반환하는 방식으로 구현하였다.

이 과정에서 문자열을 반으로 나누게 되는데, 문자열의 길이가 홀수인가 짝수인가에 따라 접미사를 자르는 인덱스가 달라지는 것에 주의하자.

