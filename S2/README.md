# BOJ_S2
백준 온라인 저지 silver 2 난이도 문제풀이입니다.

---

## 2304 - 창고 다각형

0부터 1000 사이의 N개의 기둥들의 위치와 높이가 주어진다. 이 기둥들을 모두 덮는 지붕을 만든다고 할때, 오목한 부분이 없도록, 최소 면적의 지붕을 계산하여 건물 단면의 면적을 출력하는 문제.

가장 높은 기둥의 높이를 먼저 구하고, 해당 높이의 기둥이 여러개 있을 경우를 대비하여, 해당 높이의 기둥 중 가장 왼쪽에 있는 기둥의 인덱스를 구하고, 해당 높이의 기둥 중 가장 오른쪽에 있는 기둥의 인덱스를 구한다.

가장 높은 기둥이 여러개 있는 경우, 가장 왼쪽 기둥과 가장 오른쪽 기둥 사이의 면적을 면적에 더해주고,

그렇지 않다면 해당 기둥의 높이를 면적에 더해준다.

그리고 왼쪽부터 1씩 인덱스를 높여가면서 자신보다 큰 기둥이 나오기 전까지 자신의 높이를 면적에 더해주고, 자신보다 큰 기둥이 나오면 해당 기둥의 높이를 면적에 더해주기 시작한다.

오른쪽도 같은 방식으로 더해준다.

위 방식을 최대 높이 기둥을 만날 때까지 반복해주면 최종면적이 나오게 된다. 

## 2615 - 오목

22.08.16 풀이

19 x 19 오목판에서 1과 2가 오목을 한다고 할 때, 진행중인 오목판이 입력으로 주어지고, 오목이 완성되었다면 승자와 함께 오목이 완성된 위치를 출력하는 문제

6목은 허용되지 않으며, 오목이 완성된 경우 가장 왼쪽의 위치를, 세로로 완성된 경우 가장 위쪽의 위치를 출력한다. 승부가 나지 않은 경우, 0을 출력한다.

각 위치에 대해 오목이 완성될 수 있는 경우는 네 가지, 우측, 우상측, 우하측, 하측.

네 방향에 대해 `int[] dr = { 0, -1, 1, 1 }; int[] dc = { 1, 1, 1, 0 };`으로 델타 이동을 잡고, 해당 칸에 대해 오목이 완성되었는지 확인하는 메소드를 작성하였다. 

이 때, 놓친 부분은 두가지. 

1. 6목을 허용하지 않기 때문에, 6번째 칸도 같은지 확인해야한다.

2. 6목을 확인하고 넘어간 경우, 두번째칸에서 다시 탐색할 때, 6목을 걸러내지 못하기 때문에 반대방향 한칸도 같은지 확인해야했다.

이 두가지를 확인하며 메소드를 작성하고 true가 나온 경우의 위치를 출력하는 것으로 풀이하였다. 

승부가 나지 않는 경우 0을 출력하는 것도 잊으면 안된다.

## 11053 - 가장 긴 증가하는 부분 수열

22.08.18 풀이

길이 N의 수열을 입력받아, 해당 수열의 부분 수열 중에서 값이 순차적으로 증가하는 부분 수열의 최대 길이를 구해 출력하는 문제

DP를 활용하여 풀이하였다.

맨 앞칸부터 해당 칸을 마지막으로하는 부분 수열의 최댓값을 저장하는 방식으로, dp배열에 저장하였다.

특정칸의 값보다 작은 값을 가지는 그 이전 칸들 중 최대 길이에 1을 더한 길이를 해당 칸의 dp배열에 저장하는 방식으로 풀이하였다.

마지막 칸까지 모두 dp배열을 채웠다면, dp배열에 저장된 값들 중 가장 큰 값을 출력한다.

## 14430 - 자원 캐기

r x c 크기의 2차원 배열이 0과 1로 채워져있다. (0, 0)에서 출발하는 기계가 오른쪽과 아래로만 이동할 수 있다고 할 때, 가장 오른쪽 아래에 도착했을 때, 기계가 지날 수 있는 1의 갯수 중 최대를 구하는 문제

DP를 활용하는 문제.

각 칸에 도달할 수 있는 방법은 왼쪽과 위쪽에서 오는 두가지 방법 뿐이다.

따라서, 각 칸에 대해 왼쪽과 위쪽 중에서 더 많은 1을 지난 경로에 현재 칸의 값을 더해주면 그 칸까지 도달하는 데에 최대값을 구할 수 있다.

단, 시작지점인 (0, 0)은 해당 칸의 값으로 시작하게 하였고,

왼쪽 경계선의 경우, 위쪽에서 오는 방법 밖에 없기 때문에 위쪽 dp값에 해당칸의 배열 값을 더해주었고,

위쪽 경계선의 경우 마찬가지로, 왼쪽에서 오는 방법밖에 없기 때문에 왼쪽 dp값에 해당칸의 배열값을 더해주었다.

위와 같은 방식으로 모든 칸에 대해 dp값을 만들어 주었고 마지막으로 가장 오른쪽 아래칸의 dp값을 출력해주는 것으로 풀이하였다.

