# BOJ_G3
백준 온라인 저지 gold 3 난이도 문제풀이입니다.

---

## 1600 - 말이 되고픈 원숭이

22.10.07 풀이

왼쪽위에서 출발하는 원숭이가 오른쪽 아래로 이동할 수 있다고 할 때, K번 이하로만 나이트처럼 이동할 수 있다. 오른쪽 아래에 가장 빨리 돌달하는 이동 횟수를 구하는 문제

BFS를 이용하여 풀이하였다.

움직일 수 있는 방향이 상하좌우, 나이트 이동방식 8가지 총 12가지가 있으며, Queue에 추가하기 전에 나이트 이동 횟수를 파악하였다.

이때, 방문 처리를 말처럼 이동할 수 있는 횟수만큼 만들어 줘야 한다.

왜냐하면, 특정 위치에 도달하기 전에 말처럼 이동했다면, 해당 위치에 말처럼 이동하지 않은 채로 이동하는 경우, 해당 위치가 Queue에 들어가지 않는다는 문제가 있다.

따라서, 말처럼 이동한 횟수의 방문처리 배열에서 방문처리를 해주는 것을 통해서, 특정 칸마다 말처럼 이동한 횟수만큼 경우의 수가 생긴다.

## 2206 - 벽 부수고 이동하기

22.10.13 풀이

왼쪽 위에서 출발하여 오른쪽 아래에 도달한다고 할 때, 한 번에 한해 벽을 부술 수 있다. 최단 거리를 구하는 문제

bfs로 풀이하였다.

다만, 한번에 한해서 벽을 부술 수 있기 때문에, 벽을 부순 후의 방문 처리 배열과 벽을 부수기 전의 방문처리 배열을 따로 만들어 줘야한다.

방문 처리 배열을 2개 만들어 줘야한다는 것만 유의하면 일반적인 bfs 문제이다.

## 2655 - 가장높은탑쌓기

N의 벽돌의 각 밑면적의 넓이, 높이, 무게가 주어진다. 넓이가 더 큰 벽돌을 위에 쌓을 수 없고, 무게가 무거운 벽돌을 위에 쌓을 수 없다고 할 때, 최대 높이만큼 쌓았을 때의 벽돌의 수와 쌓은 순서대로 벽돌의 번호를 출력하는 문제.

두 가지 조건을 모두 충족해야 한 벽돌을 쌓을 수 있기 때문에, 한 가지 조건을 쉽게 접근하고자 밑넓이를 기준으로 정렬을 해주었다. 이 과정에서 벽돌의 순서가 바뀌기 때문에 미리 벽돌에 번호까지 입력을 해두었다.

밑넓이를 기준으로 정렬을 하였기 때문에, 이제 자신보다 앞에 있는 블럭 중 무게가 가벼운 것 밑으로는 들어갈 수 있다고 생각할 수 있다.

이제 DP 배열을 생성한다. 

위에서 말한 바와 같이, 밑넓이를 기준으로 정렬하였기에 자신보다 앞쪽에 있는 벽돌 중에서 무게가 가벼운 벽돌만 고려하여 DP배열을 채워 나갔다.

DP배열은 i번째 블럭이 가장 밑인 탑의 최대 높이를 저장하게 된다. 따라서, 자신보다 앞쪽의 자신보다 가벼운 벽돌 중에서 최대 높이를 가진 벽돌 밑으로 자신이 들어간다고 보면 된다.

이때, 벽돌의 순서를 기억해야하기 때문에 2차원 배열을 통해, 자기 자신 바로 위 블럭의 번호와 인덱스로 같이 저장할 수 있도록 하였다.

DP배열을 모두 채운 뒤, 가장 높은 탑을 가지는 블럭부터 시작하여 차례대로 거슬러 올라가는 방식으로 풀이하였다.

## 16235 - 나무 제테크

22.10.31 풀이

봄여름가을겨울 동안 나무들이 어떻게 동작하는 지 주어지고, K년 뒤에 살아남은 나무들의 수를 구하는 문제

위치와 나이를 저장하는 Tree 클래스를 만들어 사용하였다.

각 칸별로 List를 만들어, Tree를 저장하였다.

처음 나무들을 입력받은 뒤, 나이순으로 정렬하였다. 그 이유는 양분을 나이가 적은 순서대로 먹기 때문이다.

그 뒤에는 K년 동안, 각 칸에 대해, 양분이 충분하다면 먹고, 양분이 부족해지는 시점에서의 인덱스를 기억해둔 뒤, 해당 인덱스 뒤로는 모두 양분을 못 먹기 때문에, 죽으면서 양분이 되도록 하였다.

위 과정이 가능한 이유는, List를 처음에 한번만 정렬하고, 나무가 추가될 때는 앞쪽에 추가하는 것을 통해, 오름차순이 유지되도록 했기 때문이다.

마지막엔, 모든 칸에 있는 나무들의 수를 더해서 출력하였다.

> 어려웠던 점

1. 가장 처음에는 모든 나무들의 List를 한번에 관리하고자 하였다. 이렇게 할 경우, 매년 나이순으로 정렬해주는 것이 필요했고, 이 과정에서 시간초과가 발생한 것 같다.

2. 각 칸의 Tree List를 처음에 LinkedList로 선언하였다. 그 이유는 추가과 삭제가 빈번하게 일어나기 때문이었다. 하지만, 양분이 부족한 나무들을 삭제하는 과정에서 인덱스로 반복적으로 접근하기 때문에 ArrayList가 더 적합하였다.

## 16236 - 아기 상어

22.09.30 풀이

아기 상어의 위치와 크기가 다른 물고기들의 위치가 주어진다. 아기 상어는 자신 보다 작은 크기의 물고기 중 가장 가까운 물고기를 먹고, 자신의 크기와 같은 수의 물고기를 먹으면 크기가 1 커진다.

위 큐칙을 바탕으로 좌표위에 있는 가능한 모든 물고기를 먹는 데까지 걸리는 시간을 구하는 문제

현재 아기 상어의 위치에서 bfs를 통해 자신이 먹을 수 있는 물고기들의 위치를 PriorityQueue에 저장하였다.

PriorityQueue에 저장하여 정렬하는 기준은 가장 먼저 현재 아기 상어로부터의 거리, 그 거리가 같다면 행, 행이 같다면 열 기준으로 PQ에서 Comparator를 통해 정렬하였다.

해당 PQ에서 먹으러 가는 물고기의 좌표를 얻어와, 해당 위치로 아기상어를 옮기고 원래 자리는 0으로 되돌려 놓았다.

그리고 먹은 물고기의 수를 1 늘리고, 해당 위치까지 간 거리를 전체 답에 추가해 주었다.

위 과정을 반복하다가, bfs에서 더 이상 먹을 수 있는 물고기가 없다면 동작을 멈추는 방식으로 풀이하였다.

> 어려웠던 점

물고기의 크기가 1부터 6으로 제한되어 있었기 때문에, 상어의 크기는 7이기만 하면 되었으나, 계속해서 증가하도록 코드를 만들어 놓아서, 9를 넘어가는 순간 자기 자신을 계속해서 물고기로 인식하는 문제가 있었다.

따라서, 상어의 크기를 7로 제한해 주는 것을 통해서 풀이하였다.

## 17135 - 캐슬 디펜스

22.10.28 풀이

게임의 규칙이 주어지고, 궁수를 배치하는 위치를 정할 수 있다고 할 때, 가장 많은 적을 쓰러뜨리는 경우, 몇명의 적을 제거했는 지 구하는 문제

적들의 위치와 화살을 맞았는 지 확인하는 정보를 담은 Enemy 클래스를 만들어 사용하였다.

궁수로부터 거리순으로 정렬하기 위해, compareTo 메소드를 재정의하여 사용하였다.

또한, 궁수로부터의 거리를 반환하는 메소드와 깊은 복사를 위해 객체를 복사하는 메소드도 만들어 사용하였다.

각 궁수가 정해질 때마다, PriorityQueue를 만들어 가장 가까운 적을 제거할 수 있도록 하였다.